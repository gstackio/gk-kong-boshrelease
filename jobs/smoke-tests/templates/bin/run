#!/usr/bin/env bash
<%
    require "shellwords"
    def esc(x)
        Shellwords.shellescape(x)
    end

    adm_username = link("kong").p("admin.basic_auth.username")
    adm_password = link("kong").p("admin.basic_auth.password")
    adm_path = link("kong").p("admin.service.route_path")

    if link("kong").p("proxy.tls.enabled")
        pxy_scheme = "https"
        pxy_port = link("kong").p("proxy.tls.bind_port")
    else
        pxy_scheme = "http"
        pxy_port = link("kong").p("proxy.bind_port")
    end

    main_address = link("kong").instances.first.address
-%>

set -eo pipefail

function prepend_datetime() {
    awk -W interactive '{ system("echo -n [$(date +%FT%T%z)]"); print " " $0 }'
}

exec \
    3>&1 \
    1> >(prepend_datetime >&3) \
    2>&1

readonly ADM_BASE_URI=<%= esc("#{pxy_scheme}://#{main_address}:#{pxy_port}#{adm_path}") %>
readonly PXY_BASE_URI=<%= esc("#{pxy_scheme}://#{main_address}:#{pxy_port}") %>
readonly API_NAME=smoke-tests-mockbin-api
readonly SERVICE_ID=be7c18b4-8d1b-4368-b617-3661ccf663f0
readonly ROUTE_ID=e4a90873-8af0-44e9-a31f-9b4b08df9919

# setup cleanup framework
defer_stack=()
function defer() {
    local function_name=$1

    local new_stack=("${function_name}")
    new_stack+=("${defer_stack[@]}")

    defer_stack=("${new_stack[@]}")
}
function run_deferred() {
    set +e
    for fn in "${defer_stack[@]}"; do
        "${fn}"
    done
}

trap run_deferred EXIT

# setup .netrc for curl to fetch the login name and password
export HOME=/var/vcap/data/smoke-tests/fake-home
mkdir -p "${HOME}"
touch "${HOME}/.netrc"
chmod 600 "${HOME}/.netrc" # restrict access before writing content
echo <%= esc("machine #{main_address} login #{adm_username} password #{adm_password}") %> \
    > "${HOME}/.netrc"

function cleanup_netrc() {
    rm -f "${HOME}/.netrc"
}
defer cleanup_netrc

function request() {
    local base=$1 ca_name=$2 verb=$3 uri_path=$4; shift 4

    (
        set -x
        curl -fsSL -X "${verb}" \
            --cacert "/var/vcap/jobs/smoke-tests/tls/${ca_name}.crt" \
            --url "${base}${uri_path}" \
            "$@" \
            --include
    )
}

function admin() {
    request "${ADM_BASE_URI}" "admin_ca" "$@" --netrc
}

function proxy() {
    request "${PXY_BASE_URI}" "proxy_ca" "$@"
}



# query the 'info' endpoint
admin GET "/" \
    | tr -d '\r' | sed -e '/^$/,$d' # only display the HTTP response headers
echo $'\n'



function cleanup_service() {
    # delete the Service
    admin DELETE "/services/${SERVICE_ID}"
}

cleanup_service || true # cleanup any stale Service

# create a backend Service
admin PUT "/services/${SERVICE_ID}" \
    --data "url=https://mockbin.org"
echo $'\n'

# delete the created Service uppon exit
defer cleanup_service

# wait for the Service to be created
sleep $((<%= esc(link("kong").p("datastore.db_update_frequency_in_sec")) %> + 1))

# get the created Service
admin GET "/services/${SERVICE_ID}"
echo $'\n'


function cleanup_route() {
    # delete the Route
    admin DELETE "/routes/${ROUTE_ID}"
}

cleanup_route || true # cleanup any stale Route

# create a backend Route
admin PUT "/routes/${ROUTE_ID}" \
    --data "hosts=example.org" \
    --data "service.id=${SERVICE_ID}"
echo $'\n'

# delete the created Route uppon exit
defer cleanup_route

# wait for the Route to be created
sleep $((<%= esc(link("kong").p("datastore.db_update_frequency_in_sec")) %> + 1))

# get the created Route
admin GET "/routes/${ROUTE_ID}"
echo $'\n'


# send a request through the Route and Service
proxy GET "/request?toto=titi&tata=tutu" \
        --header "Host: example.org" \
        --header "Content-Type: application/json" \
        --data-raw '{"plip": "plop"}' \
    | tr -d '\r' | sed -e '/^$/,$d' # only display the HTTP response headers
echo $'\n'



exit 0
